
Spring microservices ->

    first create maven project and in pom.xml file insert spring-boot-dependencies dependency inside.
    we can use spring boot directly as a parent project we can directly describe in properties which
    version we want for all our dependencies by creating a tag in properties tag
    we can write the dependencies which we want common for all project in the parent project
    so the parent project is the project which contains all the subprojects
    then create the module and specify your first service in our case it is customer
    then specify the dependency which u wanted for that perticuler project

    for sending request from one service to another ->
    1. using restTemplate -> create the bean of restTemplate and use it
                             there are various methods present inside restTemplate

    we can have two or more instances of one service

    2. using Service discovery ->
    The process of automatically detecting devices and services on a network
    It includes eureka client and eureka server
    for eureka server create the one eureka server and register the other services as client to the eureka server
    default port for eureka server is 8761
    when register clients to the service discovery then we can talk to the services through the server and not through the individual service
    for service discovery u don't need to specify the port name in rest template method u just need to give the name of application and the above address
    for using the server u have to give the @LoadBalanced annotation over the restTemplate bean so the server will not get confused if the service have two
    or more instances and the application will not fail

    3. using openFeign or feignClient ->
    write the dependency of feign client in the main pom
    then crate the new module and in that module create the feign client means create the interface
    and give declaration of controller which u want to access from another service and path of that service
    then in the service from which u want to call the another class service write the dependency of that created module means client module
    then give the enableFeignClient annotation to the service from which u want to call the another service
    and describe the base package means path of that interface in which we have specify the client

    LoadBalancer ->
    If there are many clients, and we want to manage the load on our application at that time we use load balancer, It is the main entry point of the application
    request comes in through the load balancer
    there are two types of load balancer one is main load balancer and others are internal load balancers which are used for internal communication
    LoadBalancer Algorithm -> the load balancer algorithm comes into the picture when we have two instances of one microservice and both are healthy then where should
    request go is dependent on load balancer algorithm which we choose common is round rubbing which works on sending request sequentially
    there are different ways also to check the service is ok and healthy

    To implement load balancer, we have to use api-gateway ->
    Api-Gateway ->
    so every request first goes to api gateway and through the load balancer according to the health checks.
    You have to define routes in the application.yml file so for that particular route the request will be sent to that particular service

    Message que ->
    publisher -> broker -> consumer.
    These three can be on different machines.

    Dockereshwar ->
    Main purpose of docker is we can run our application on any environment,
    so we make a jar of our application and make a docker image from it and run it through the container that's a basic idea

    Docker image ->
    docker image is a template for running our application from one docker image u can run many containers
    image is a file used to execute code in a docker container
    image contains source code , dependencies and anything which is required to run an application
    it is a blueprint from which we can run multiple containers

    Docker container ->
    It is an isolated environment for running applications
    it contains everything your application needs ex - os, tools, software's

    Docker Architecture ->
    It follows client server approach
    Client -> server {Docker Host [Here our application runs(contains docker daemon)]} -> Registries

    Docker Registry ->
    It is a storage and distribution system for docker images like dockerHub
    we have two types -> public and private
    docker pull and push -> with this command we can pull or push the images locally
    docker hub is most popular among all of them

    Building docker image ->
    we have to create Dockerfile where we spacify some properties
    1. from (where u want to build) - openjdk 17
    2. expose (port which u  want to expose) - 8080
    3. add (path of jar, jar name)
    4. entrypoint (command to run jar) - ["java","-jar","jar name"]

    5. for building image run command from directory -> docker build -t "name of jar" .
    6. check docker image locally present - docker image ls
    7. running image - docker run -p on which port you want to run:localPort "jar name"

















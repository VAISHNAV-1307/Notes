
                                                    || जय शंकर ||

Spring Security is all about application level security
It is distributed in two levels 1. Authentication , 2. Authorization
1. Authentication -> Authentication is the logic in the application which will figure out who is the user which is trying to access the application and
   is he allowed to access the application.
2. Authorization -> Authorization is providing access to particular things or functions based on authority or roles

In the micro services we secure the api endpoints


1. HTTP Basic Authentication ->
    How to provide credentials
    - To know how to provide credentials we should know, which type of authentication is getting used by application
    - By default it uses HTTP basic type of authentication
    - In case of HTTP basic we need to send the authentication credentials in the HTTP headers which will be base64 encoded
    - In the postman we can directly have the option to navigate to authorization tab and select the option of Basic Auth and then provide the credentials
    - By default user will always be user and when we did not done any configuration for the password the password will be self generated password by the
      spring security

    How does it work ->
    - When in postman we select the basic authentication header has been created which is usually hidden called Authorization as key
      and for value it will contain in the format of -> "Basic" "Base64 encoded string of password which we have provided"
    - Base64 is encoding not an encryption

Difference between Encoding, Encryption and Hsh Functions
1. Encoding ->
    . Encoding is only a function that it is always possible to reverse somehow. It is just a mathematical transformation that doesn't need a secret to be
      known to revert it.
    . Encoding is only a mathematical function that transforms an input into an output in such a way in which you can always revers an output and find out
      the input if you know the rule or pattern by which it is transformed

2. Encryption ->
    . It is transforming an input into output but to go back from output to input we always need secret, so not everyone is able to find out which was the
      input after encryption function
    . we can say it is a more particular way of encoding
    . It is still a transformation function but it implies that you always need a secret to revert back

3. Hash Functions ->
    . In it we can always go from input to output
    . But by any means we cannot go from output to input
    . going from output to input is not possible
    . Input and output are always related to each other means gets transformed in same way everytime
    . Hash functions are preferred way to store the passwords
    . then we can encrypt the input and match it with the stored encrypted output

Note - in the real world we never use http basic we always go with the https to make sure that what we send on the wire is encrypted and https makes it sure

How to create own set of credentials Basic [refer example project 1]
1. Create own user details service , it is a component that manages user details
   the component which we create in the application to tell the spring security where to get the user details
2. Add bean in the context of type userDetailService it is an interface that defines spring security that it is a manager of the user credentials, we have
   different types of managers which extends or implements UserDetailsService
3. In this contract we have a method which takes the userName which is unique identifier and provides the userDetails which is the everything which
   applications needs to know about the user
4. Create the user with the user class provided by spring security
5. Create the own password encoder Bean

Note - If we crete our own user management spring security will not provide the randomly generated password

Authentication architecture
. Spring security starts in the web applications from the filters
. Filters -> Servlets -> FrontController -> then rest of the spring boot flow
. whenever the request enters in the filterChain which is the chain of multiple filters then authentication filter delegates to the AuthenticationManager
. then authentication manager is an object whose purpose is to find the way in which they can authenticate the users
. Authentication manager is implemented by the objects called authenticationProviders
. We do have only one authentication manager but we can have one or more authentication providers.
. Whenever authentication provider needs an username and password it uses two components 1. userDetailsService and 2. PasswordEncoder
. and if authentication is successful then it stores the authentication object in the security context

AuthenticationFilter -> AuthenticationManager -> AuthenticationProvider -> UserDetailsService
                                                                        -> PasswordEncoder

---

UserDetailsService -> [refer example project 2]
. In the user details service we have only one method called loadUserByUserName(String userName)
. which will take the username and return the userDetails object
. that's what we need to implement
. to implement loadUserByUserName we have so many options but we will go with the loading the user from db
. then we need to create a service class which implements UserDetailsService and then implement the loadUserByUserName and in the implementation we load the
  user by username from the db
. so when we load the user from db it will be in the user entity
. and spring security only understand the users which are in userDetails object
. so we need to implement userDetails interface with our entity class indirectly by using dto's or by using adapter pattern in which we adapt the entity
  to desired interface

Authorities -> Authorities is the list of actions which user can do
. UserDetails object has one field called GrantedAuthorities
. and authorities are represented as authorities and roles
. it is just a conceptional difference but behind the scene it is the same nothing is different
. authorities means actions -> read, write , delete
. roles means it is a badge -> admin , client, manager, visitor
. basically its same , like how we want to implement the authorization based on actions or badges

---

Defining custom authentication mechanism [refer example project 3]
1. Create custom Filter, Authentication manager, Authentication provider, authentication.
2. In the config class override the bean for filterChain and add the custom filter in the filter chain
3. Override the filter method of the custom filter by using authenticationManager
4. In the authentication manager provides the provider which supports the custom authentication
5. In the provider write the logic for authenticating the authentication object
6. Once object is authenticated save the authentication object in the security context
7. After that we can send the request in the next filter by doFilter method from the filterChain

Architectural diagram : Custom Authentication obj -> Custom Filter impl -> Custom Manager impl -> Custom Provider impl

---

Implementing multiple authentication providers by implementing httpBasic(default) and custom authentication(api key) [refer example project 4]
HttpBasic -> When we create the bean of httpBasic what will happen behind the scenes the security configurer is created and
             filters will be created and authentication manager, Authentication provider will be created with the default values we can change there values
             as well while creating the bean of the security filter chain and according the our provided config the whole structure will get created.

For adding more authentication logic , we need to write the different logics through which we want to authenticate our request and then we can
configure it in security configurations.

---

There are two types of authorization - 1. End point level authorization -> Done through the filter chain
                                      - 2. Method level authorization -> Done through the AOP
In the web apps we used end point level authorization

---

End point level authorization
- Architecture -> AuthenticationFilter - SecurityContext - AuthorizationFilter

- End point level authorization will happen through the filter chain and this is where the rules are applied
- there is a method in the httpBasic called authorizedRequest which will specify the filter that how the request need to be authorized
  so when we called an endpoint basis on this specifications our request will get passed or not in the authorization before reaching out the controllers
- The authorization is divided in two parts
- anyRequest() -> Matcher method
  authenticated() -> Authorization rule
- anyRequest().authenticated() -> This complete means after the authentication whatever user there is in the security context that user is authorized

Authorization Rules in Detailed
1. authenticated() -> This means all the users which are authenticated are authorized
2. permitAll() -> - This means even the authentication is also not needed you can permit whatever comes in
                  - however this will allow without auth but if you tries to access it with the wrong username or password this will not allow you
                  - cause the authentication that the httpRequest goes into authentication filter and when the authentication request is successful
                    it will create the securityContext and then the authorization filter applies , so it will always be the authentication before authorization
                    ,so when we go with the no auth it will completely skip the proceeder and the endpoint if is marked as permit all then the authorization
                    will allow.
                  - But if we say we want to go with the basic or any other authentication then the authentication filter tries to authenticate you and that's
                    before the authorization filter can check that the rule is permit all and it will directly get thrown out of the filterChain and request
                    never reaches the authorization filter where it can check that rule is permit all so it can allow the request
3. denyAll() -> Which means denyAll the request, which really didn't make any sense in the real world application, we can use it to denyAll the request
                which are not specifically mentioned or denyAll the request which are specifically mentioned
4. hasAuthority()
5. hasAnyAuthority()
6. hasRole()
7. hasAnyRole()

---

Note - 401 means authentication fails
       403 means authorization fails
       there messages are vise-versa but dont get confuse












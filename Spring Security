
                                                    || जय शंकर ||

Spring Security is all about application level security
It is distributed in two levels 1. Authentication , 2. Authorization
1. Authentication -> Authentication is the logic in the application which will figure out who is the user which is trying to access the application and
   is he allowed to access the application.
2. Authorization -> Authorization is providing access to particular things or functions based on authority or roles

In the micro services we secure the api endpoints


1. HTTP Basic Authentication ->
    How to provide credentials
    - To know how to provide credentials we should know, which type of authentication is getting used by application
    - By default it uses HTTP basic type of authentication
    - In case of HTTP basic we need to send the authentication credentials in the HTTP headers which will be base64 encoded
    - In the postman we can directly have the option to navigate to authorization tab and select the option of Basic Auth and then provide the credentials
    - By default user will always be user and when we did not done any configuration for the password the password will be self generated password by the
      spring security

    How does it work ->
    - When in postman we select the basic authentication header has been created which is usually hidden called Authorization as key
      and for value it will contain in the format of -> "Basic" "Base64 encoded string of password which we have provided"
    - Base64 is encoding not an encryption

Difference between Encoding, Encryption and Hsh Functions
1. Encoding ->
    . Encoding is only a function that it is always possible to reverse somehow. It is just a mathematical transformation that doesn't need a secret to be
      known to revert it.
    . Encoding is only a mathematical function that transforms an input into an output in such a way in which you can always revers an output and find out
      the input if you know the rule or pattern by which it is transformed

2. Encryption ->
    . It is transforming an input into output but to go back from output to input we always need secret, so not everyone is able to find out which was the
      input after encryption function
    . we can say it is a more particular way of encoding
    . It is still a transformation function but it implies that you always need a secret to revert back

3. Hash Functions ->
    . In it we can always go from input to output
    . But by any means we cannot go from output to input
    . going from output to input is not possible
    . Input and output are always related to each other means gets transformed in same way everytime
    . Hash functions are preferred way to store the passwords
    . then we can encrypt the input and match it with the stored encrypted output

Note - in the real world we never use http basic we always go with the https to make sure that what we send on the wire is encrypted and https makes it sure

How to create own set of credentials Basic [refer example project 1]
1. Create own user details service , it is a component that manages user details
   the component which we create in the application to tell the spring security where to get the user details
2. Add bean in the context of type userDetailService it is an interface that defines spring security that it is a manager of the user credentials, we have
   different types of managers which extends or implements UserDetailsService
3. In this contract we have a method which takes the userName which is unique identifier and provides the userDetails which is the everything which
   applications needs to know about the user
4. Create the user with the user class provided by spring security
5. Create the own password encoder Bean

Note - If we crete our own user management spring security will not provide the randomly generated password

Authentication architecture
. Spring security starts in the web applications from the filters
. Filters -> Servlets -> FrontController -> then rest of the spring boot flow
. whenever the request enters in the filterChain which is the chain of multiple filters then authentication filter delegates to the AuthenticationManager
. then authentication manager is an object whose purpose is to find the way in which they can authenticate the users
. Authentication manager is implemented by the objects called authenticationProviders
. We do have only one authentication manager but we can have one or more authentication providers.
. Whenever authentication provider needs an username and password it uses two components 1. userDetailsService and 2. PasswordEncoder
. and if authentication is successful then it stores the authentication object in the security context

AuthenticationFilter -> AuthenticationManager -> AuthenticationProvider -> UserDetailsService
                                                                        -> PasswordEncoder

---

UserDetailsService -> [refer example project 2]
. In the user details service we have only one method called loadUserByUserName(String userName)
. which will take the username and return the userDetails object
. that's what we need to implement
. to implement loadUserByUserName we have so many options but we will go with the loading the user from db
. then we need to create a service class which implements UserDetailsService and then implement the loadUserByUserName and in the implementation we load the
  user by username from the db
. so when we load the user from db it will be in the user entity
. and spring security only understand the users which are in userDetails object
. so we need to implement userDetails interface with our entity class indirectly by using dto's or by using adapter pattern in which we adapt the entity
  to desired interface

Authorities -> Authorities is the list of actions which user can do
. UserDetails object has one field called GrantedAuthorities
. and authorities are represented as authorities and roles
. it is just a conceptional difference but behind the scene it is the same nothing is different
. authorities means actions -> read, write , delete
. roles means it is a badge -> admin , client, manager, visitor
. basically its same , like how we want to implement the authorization based on actions or badges

---

Defining custom authentication mechanism [refer example project 3]
1. Create custom Filter, Authentication manager, Authentication provider, authentication.
2. In the config class override the bean for filterChain and add the custom filter in the filter chain
3. Override the filter method of the custom filter by using authenticationManager
4. In the authentication manager provides the provider which supports the custom authentication
5. In the provider write the logic for authenticating the authentication object
6. Once object is authenticated save the authentication object in the security context
7. After that we can send the request in the next filter by doFilter method from the filterChain

Architectural diagram : Custom Authentication obj -> Custom Filter impl -> Custom Manager impl -> Custom Provider impl

---

Implementing multiple authentication providers by implementing httpBasic(default) and custom authentication(api key) [refer example project 4]
HttpBasic -> When we create the bean of httpBasic what will happen behind the scenes the security configurer is created and
             filters will be created and authentication manager, Authentication provider will be created with the default values we can change there values
             as well while creating the bean of the security filter chain and according the our provided config the whole structure will get created.

For adding more authentication logic , we need to write the different logics through which we want to authenticate our request and then we can
configure it in security configurations.

---

There are two types of authorization - 1. End point level authorization -> Done through the filter chain
                                      - 2. Method level authorization -> Done through the AOP
In the web apps we used end point level authorization

---

End point level authorization
- Architecture -> AuthenticationFilter - SecurityContext - AuthorizationFilter

- End point level authorization will happen through the filter chain and this is where the rules are applied
- there is a method in the httpBasic called authorizedRequest which will specify the filter that how the request need to be authorized
  so when we called an endpoint basis on this specifications our request will get passed or not in the authorization before reaching out the controllers
- The authorization is divided in two parts
- anyRequest() -> Matcher method
  authenticated() -> Authorization rule
- anyRequest().authenticated() -> This complete means after the authentication whatever user there is in the security context that user is authorized

---

Authorization Rules in Detailed [refer ex - 5]
- It will specify the rules for authorization which user should have
1. authenticated() -> This means all the users which are authenticated are authorized
2. permitAll() -> - This means even the authentication is also not needed you can permit whatever comes in
                  - however this will allow without auth but if you tries to access it with the wrong username or password this will not allow you
                  - cause the authentication that the httpRequest goes into authentication filter and when the authentication request is successful
                    it will create the securityContext and then the authorization filter applies , so it will always be the authentication before authorization
                    ,so when we go with the no auth it will completely skip the proceeder and the endpoint if is marked as permit all then the authorization
                    will allow.
                  - But if we say we want to go with the basic or any other authentication then the authentication filter tries to authenticate you and that's
                    before the authorization filter can check that the rule is permit all and it will directly get thrown out of the filterChain and request
                    never reaches the authorization filter where it can check that rule is permit all so it can allow the request
3. denyAll() -> Which means denyAll the request, which really didn't make any sense in the real world application, we can use it to denyAll the request
                which are not specifically mentioned or denyAll the request which are specifically mentioned
4. hasAuthority (GrantedAuthorities authority) -> Allow the users having mentioned authority
5. hasAnyAuthority (List<GrantedAuthority> authorities) -> Allow the users having mentioned authorities
6. hasRole (GrantedAuthorities authority) -> Allow the users having mentioned Role
7. hasAnyRole (List<GrantedAuthority> authorities) -> Allow the users having mentioned role.
8. access(new WebExpressionAuthorizationManager(String rule)) -> we can specify the authorization rule in form of SpEL in the string input and we can
                                                                 define the complex logics over there. Its very powerful rule.

---

Matcher methods in details [refer ex - 6]
- It will specify for which api endpoints, we are doing this authorization rule check
- requestMatchers(String patterns) -->
  - With this we can specify which apis we need to authorize and which authorization rules should get applied on the specific apis
    we can specify different rules for different apis, we can specify it in the patterns as well
  - most of the times we need a group of apis having same authorization rules so at that time we generally specify the common prefix of all the apis
    in the requestMatchers input.
  - Some Imp Ant expressions ->
    - * means anything only once and ** means all the path is anything
        . /demo/** -> This means all the path after demo prefix
        . /demo/* -> This means only one anything after demo
        . /demo/anything/*/something -> This means demo after that anything after that any api and after that something
  - In the requestMatchers we can specify the method as well let say we want to apply the rule for only GET apis with the particular prefix then we can
    specify it in the method parameters

---

Notes -> To define the Role we have a grantedAuthority contract which is used to define both role as well as authorities.
         So to define the roles we can define it like in the authorities field of user class we can define the role as ROLE_ADMIN, ROLE_DEVELOPER
         or we can directly use the role field of user class and define the role directly as ADMIN
         implicitly role field is doing the same by creating the granted authority by adding the prefix as ROLE

---

Note - 401 means authentication fails
       403 means authorization fails
       there messages are vise-versa but dont get confuse
       Authorities are on server side always, we did not send it through headers or somehow

---

Method based authorization [Aspect based] [Refer Example - 7]
- We can apply authorization directly on service level and on any bean.
- method level authorization is also used the security context info
- for the method level authorization we can use the @PreAuthorize Annotation on top of method and there we can specify the authorization rules
    - We have four annotation to define method level authorization
      1. PreAuthorize -> Authorize before method execution
      2. PostAuthorize -> Authorize after method execution and before return
      3. PreFilter -> Works with collection and array, it will filter the values send to the method based on condition
      4. PostFilter -> works only when return type is collection or array and filter out the returning object based on the condition
- By adding this annotation we make sure this conditions are get evaluated by spring AOP
- we can specify the rules same as we do it in the case of request matchers like hasAuthority or hasAnyAuthority and before reaching out to that method
  it will check that the user is fulfilling the authorization requirements or not
- And to use the Pre and PostAuthorization annotation we need to sure that we are enabling the aspects for spring.
- So to enable the Aspects we need to use the @EnableMethodSecurity annotation on top of SecurityConfig class

---

Method based authorization - part 2 [refer Example - 7]
- From the filter level authorization we cannot access the other things in the url like path variables, request body or request parameters
- on the method level security we can apply different rules on parameters as well
- post authorize we mainly use when we don't want to interrupt the execution but want to restrict the value which is getting returned.
- in general use we don't use postAuthorize in real world application

---

OAuth2 and openID connect
User                 -> User is the person who is sending the request to access the information in the resource server
                      . User is not mandatory it can be the API's which are trying to access the information or can be anything which are trying
                        to access the information from the resource server.
client               -> It is the front end application or any application through which user is sending the request for accessing information
Authorization server -> It is the server where all the  authentication logic is present and if authentication condition passes then only
                        authorization server is allowing user to access the information in the resource server
                      . The one of main reason to have the separate Authorization server from the resource server is that we don't want to store
                        the user details and all that information related to it in the resource server
                      . It manages the users and clients.
                      . When we go to an office building first time, we explain our identity and we get card which is token in our case, that card
                        opens some doars for us not all the doars based on privileges and that's how Authorization server works.
Resource Server      -> It is the server which is responsible for providing the resource info which user is asking, in simple words it is the backend
                        application
                       . Authentication part is taken care at the end of Authorization Server and Authorization part is taken care at the end of
                       Resource Server

Flow ->
User sends the request to the client then client send that request to the Authorization server authorization server validates the request and if
authentication is completed then send some information in form of tokens to the client then client send that info to the Resource server and then
based on information in the token Resource server can authorize the request and then send back the appropriate information to the user
1. how does client get a token (grant types)
2. how does the resource server (backend) validate and get the data with the token

Ways to obtain the token are called grant types
1. Authorization code (PKCE) [Please refer the diagram]
    - User sends the request to the client
    - Client redirect it to the login page
    - Login page is managed at the Authorization server
    - then user logged in using user credentials
    - if log in is successful Authorization server redirects the user to the redirecting URL provided by client with the authorization code
    - now client implicitly sends back the request to the authorization server with the authorization code and the client credentials
    - client credentials are stored at the end of client
    - and then finally Authorization server sends the access token
    - Use of PKCE -> it comes into picture cause we cannot save the client credentials on client server as it is the public, so that's were we can
                     use PKCE to store the client credentials

2. Client credentials
    - It comes into to picture were we don't have a user or we have another backend service or kubernetes which we need to authenticate for authorization
      server in this case that backend service becomes the client for the authorization server
    - In this case we use the client credentials
    - It is very simple
    - We just sent the client credentials to the authorization server from client
    - and then we get back the access token
    - We just need to take care that we don't allow client credentials for all the endpoints
3. Refresh token
    - The purpose of this refresh token, is allow the user to get the token without logging in again in the same session
    - When user tries to get something and access token is no longer valid now if we don't have a refresh token concept then user has to go to the all
      the process of authorization grant type again so we want to avoid that user needs to log in again and again in 15 or 20 mins
    - so instead we have a refresh token and the application memorize it and it sends the refresh token and if the refresh token is valid one
      application will send the new access token and refresh token with it.
    - and then app can do the same process again and again
    - We can expire the refresh token as well so user needs to do the login after particular period of time
4. Implicit, Password --> DEPRECATED DO NOT USE


Tokens -->
- Tokens are qualifies as opaque and non-opaque tokens
- Tokens should help the Resource server to apply the authorization rules
    - Opaque tokens -> are by definition tokens that don't contain any data
        . In case of opaque tokens the Authorization server will always implements the introspection endpoint
        . the introspection endpoint is and endpoint which gets a token and returns the details about that token
        . Information means not only that token is valid or not but info about the user that will be used by resource server to apply the authorization
          rules
        . means will get the token were we don't have values inside them but we can use the introspection endpoints to get the details about the token
        . in this case resource server always introspect the token to get the details about it.
    - Non-opaque tokens -> are the tokens that contains data [JWT is implementation of non-opaque tokens]
        . Lets stick to JWT for opaque tokens in practice will always use the jwt tokens as the opaque tokens
        . so JWT tokens is not only piece of string
        . its base64 encoding of a json
        . its composed of three parts and where third part is actually called a signature
        . the third part which is signature is offering a security over the header and the body which contains the information
        . but also on the token indeed which proves that token is created by the authorization server
        . because if the token is opaque one for the resource server it is very easy to find out if the token is valid or not
        . cause when the resource server called the introspection endpoint authorization server will tell that it is not valid
        . but in case of non-opaque token which contains the information inside resource server will not call the authorization server
        . because token is sign and resource server will be configured with the key that can validate the signature
        . so in non-opaque tokens case what will happen client will send the non-opaque token and resource server will validate the signature
          and directly get the information inside the token and we do not need to introspect it with the authorization server















